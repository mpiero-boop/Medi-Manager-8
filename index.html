/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/
import React from 'react';
import ReactDOM from 'react-dom/client';

const { useState, useEffect, useRef } = React;

// Beispieldaten
const initialMedications = [];

// Moved getInitialState outside of the App component to resolve cascading parsing and scope errors.
const getInitialState = (key, defaultValue) => {
    try {
        const storedValue = localStorage.getItem(key);
        if (storedValue) {
            return JSON.parse(storedValue);
        }
    } catch (error) {
        console.error(`Fehler beim Lesen von '${key}' aus dem localStorage:`, error);
    }
    return defaultValue;
};

const parseMedName = (fullName) => {
    const parts = fullName.split(' ');
    const strengthIndex = parts.findIndex(part => /\d/.test(part));
    if (strengthIndex > 0) {
        const name = parts.slice(0, strengthIndex).join(' ');
        const strength = parts.slice(strengthIndex).join(' ');
        return { name, strength };
    }
    return { name: fullName, strength: '' };
};

const WeekDaySelector = ({ selectedDays, onDayToggle }) => {
    const days = ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'];
    return (
        <div className="week-day-selector">
            {days.map(day => (
                <button
                    key={day}
                    className={`day-button ${selectedDays.includes(day) ? 'active' : ''}`}
                    onClick={() => onDayToggle(day)}
                    aria-pressed={selectedDays.includes(day)}
                >
                    {day}
                </button>
            ))}
        </div>
    );
};


const ManageTimesModal = ({ medName, initialSlots, initialDays, initialReminders, onSave, onClose }) => {
    const [editableSlots, setEditableSlots] = useState(() => {
        const slotsToEdit = (initialSlots && initialSlots.length > 0) ? initialSlots : [{ time: '', dosage: '1' }];
        return slotsToEdit.map((slot, index) => ({ id: Date.now() + index, time: slot.time, dosage: slot.dosage }));
    });
    const [days, setDays] = useState(initialDays || ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So']);
    const [reminders, setReminders] = useState(initialReminders !== undefined ? initialReminders : true);

    const inputsContainerRef = useRef(null);

    const handleAddSlot = () => {
        setEditableSlots(prevSlots => [...prevSlots, { id: Date.now(), time: '', dosage: '1' }]);
        setTimeout(() => {
            if (inputsContainerRef.current) {
                inputsContainerRef.current.scrollTop = inputsContainerRef.current.scrollHeight;
            }
        }, 0);
    };

    useEffect(() => {
        if (inputsContainerRef.current) {
            const inputs = inputsContainerRef.current.querySelectorAll('.time-input-row input[type="text"]');
            const lastTimeInput = inputs[inputs.length - 2]; // Focus the time input of the new row
            if (lastTimeInput) {
                lastTimeInput.focus();
            }
        }
    }, [editableSlots.length]);
    
    const handleSlotChange = (id, field, value) => {
        let formattedValue = value;
        if (field === 'time') {
            const digitsOnly = value.replace(/[^0-9]/g, "");
            const truncatedDigits = digitsOnly.slice(0, 4);
            formattedValue = truncatedDigits;
            if (truncatedDigits.length > 2) {
                formattedValue = `${truncatedDigits.slice(0, 2)}:${truncatedDigits.slice(2)}`;
            }
        } else if (field === 'dosage') {
             if (!/^\d*\.?\d*$/.test(value)) {
                return;
            }
            formattedValue = value;
        }
        setEditableSlots(
            editableSlots.map(s => (s.id === id ? { ...s, [field]: formattedValue } : s))
        );
    };
    
    const handleDayToggleInModal = (day) => {
        const newDays = days.includes(day)
            ? days.filter(d => d !== day)
            : [...days, day];
        const dayOrder = ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'];
        newDays.sort((a,b) => dayOrder.indexOf(a) - dayOrder.indexOf(b));
        setDays(newDays);
    };

    const handleRemoveSlot = (idToRemove) => {
        if (editableSlots.length > 1) {
            setEditableSlots(editableSlots.filter(t => t.id !== idToRemove));
        } else {
            alert('Es muss mindestens eine Einnahmezeit vorhanden sein.');
        }
    };
    
    const handleKeyPress = (e, index) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const currentSlot = editableSlots[index];
            if (index === editableSlots.length - 1 && currentSlot.time.trim() && currentSlot.dosage.trim()) {
                handleAddSlot();
            } else if (index < editableSlots.length - 1) {
                 if (inputsContainerRef.current) {
                    const inputs = inputsContainerRef.current.querySelectorAll('.time-input-row input[type="text"]');
                    const nextInput = inputs[(index + 1) * 2]; // Jump to the next time input
                    if (nextInput) {
                        nextInput.focus();
                    }
                }
            }
        }
    };

    const handleSave = () => {
        const timeRegex = /^([01]\d|2[0-3]):([0-5]\d)$/;
        const slotsToSave = [];
        const uniqueTimes = new Set();
        
        const filteredSlots = editableSlots.filter(s => s.time.trim() !== '');

        if (filteredSlots.length === 0) {
            alert('Bitte fügen Sie mindestens eine Einnahmezeit hinzu.');
            return;
        }

        for (const slot of filteredSlots) {
            if (!timeRegex.test(slot.time)) {
                alert('Bitte geben Sie für alle Felder eine gültige Uhrzeit im Format HH:MM ein.');
                return;
            }
            if (!slot.dosage || isNaN(parseFloat(slot.dosage)) || parseFloat(slot.dosage) <= 0) {
                 alert(`Bitte geben Sie eine gültige Dosis für die Uhrzeit ${slot.time} ein.`);
                 return;
            }
            if (uniqueTimes.has(slot.time)) {
                alert(`Die Uhrzeit ${slot.time} wurde mehrfach eingegeben.`);
                return;
            }
            uniqueTimes.add(slot.time);
            slotsToSave.push({ time: slot.time, dosage: slot.dosage });
        }

        onSave({
            slots: slotsToSave.sort((a, b) => a.time.localeCompare(b.time)),
            days: days,
            reminders: reminders,
        });
    };

    return (
        <div className="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="modal-title">
            <div className="modal-content">
                <h2 id="modal-title" className="modal-title">{medName}</h2>
                <p className="modal-description">Details bearbeiten.</p>
                
                <div className="modal-form">
                     <div className="time-inputs-list" ref={inputsContainerRef}>
                        {editableSlots.map((slot, index) => (
                            <div key={slot.id} className="time-input-row">
                                <div className="time-input-container">
                                    <input
                                        type="text"
                                        placeholder="00:00"
                                        maxLength={5}
                                        className="form-input form-input-small"
                                        value={slot.time}
                                        onChange={(e) => handleSlotChange(slot.id, 'time', e.target.value)}
                                        onKeyPress={(e) => handleKeyPress(e, index)}
                                    />
                                    <span>Uhr</span>
                                </div>
                                <div className="time-input-container">
                                    <input
                                        type="text"
                                        inputMode="decimal"
                                        placeholder="1"
                                        className="form-input form-input-small"
                                        value={slot.dosage}
                                        onChange={(e) => handleSlotChange(slot.id, 'dosage', e.target.value)}
                                        onKeyPress={(e) => handleKeyPress(e, index)}
                                    />
                                     <span>Stk.</span>
                                </div>
                                <button
                                    className="button-delete button-icon-small"
                                    onClick={() => handleRemoveSlot(slot.id)}
                                    aria-label={`Zeit ${slot.time || ''} entfernen`}
                                    disabled={editableSlots.length <= 1 && editableSlots[0].time === ''}
                                >
                                    <i className="fa-solid fa-times"></i>
                                </button>
                            </div>
                        ))}
                    </div>

                    <button className="button button-secondary add-time-button" onClick={handleAddSlot}>
                        <i className="fa-solid fa-plus"></i> Weitere Zeit hinzufügen
                    </button>
                    
                    <div className="form-group">
                        <label>Einnahmetage</label>
                        <WeekDaySelector selectedDays={days} onDayToggle={handleDayToggleInModal} />
                    </div>
                    <div className="form-group">
                        <div className="setting-item" style={{padding: 0, border: 'none'}}>
                            <label className="setting-label" htmlFor="modal-reminders-switch">Erinnerungen</label>
                            <label className="switch">
                                <input
                                    type="checkbox"
                                    id="modal-reminders-switch"
                                    checked={reminders}
                                    onChange={() => setReminders(!reminders)}
                                />
                                <span className="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>

                <div className="button-group">
                    <button className="button button-secondary" onClick={onClose}>Abbrechen</button>
                    <button className="button button-primary" onClick={handleSave}>Speichern</button>
                </div>
            </div>
        </div>
    );
};

const MultiSelectModal = ({ pharmacyStock, onClose, onAdd }) => {
    const [selectedMeds, setSelectedMeds] = useState([]);

    const handleToggleMed = (medName) => {
        setSelectedMeds(prev =>
            prev.includes(medName)
                ? prev.filter(name => name !== medName)
                : [...prev, medName]
        );
    };

    const handleAddClick = () => {
        if (selectedMeds.length > 0) {
            onAdd(selectedMeds);
        }
    };

    return (
        <div className="modal-overlay">
            <div className="modal-content">
                <h2 className="modal-title">Medikamente auswählen</h2>
                <p className="modal-description">Wählen Sie ein oder mehrere Medikamente aus Ihrem Vorrat aus.</p>

                <div className="multi-select-list">
                    {pharmacyStock.length > 0 ? (
                        pharmacyStock.map(med => (
                            <label key={med.id} className="checkbox-item">
                                <input
                                    type="checkbox"
                                    checked={selectedMeds.includes(med.name)}
                                    onChange={() => handleToggleMed(med.name)}
                                />
                                <span className="checkbox-custom"></span>
                                <span className="checkbox-label">{med.name}</span>
                            </label>
                        ))
                    ) : (
                        <p className="empty-list-text">Ihr Vorrat ist leer.</p>
                    )}
                </div>

                <div className="button-group">
                    <button className="button button-secondary" onClick={onClose}>Abbrechen</button>
                    <button className="button button-primary" onClick={handleAddClick} disabled={selectedMeds.length === 0}>
                        Hinzufügen ({selectedMeds.length})
                    </button>
                </div>
            </div>
        </div>
    );
};

const EinnahmeplanAnsicht = ({ medications, pharmacyStock, addMedication, deleteMedication, updateMedication, activeAlarms, confirmIntake }) => {
    const [editingMed, setEditingMed] = useState(null);
    const [isMultiSelectModalOpen, setIsMultiSelectModalOpen] = useState(false);
    const [medsToAddQueue, setMedsToAddQueue] = useState([]);

    useEffect(() => {
        // If there's a queue and no configuration modal is currently open...
        if (medsToAddQueue.length > 0 && !editingMed) {
            // ...open the configuration modal for the next medication in the queue.
            setEditingMed({ name: medsToAddQueue[0] });
        }
    }, [medsToAddQueue, editingMed]); // Reruns when queue changes OR when modal closes

    const handleMedUpdate = (id, field, value) => {
        const medicationToUpdate = medications.find(m => m.id === id);
        if (medicationToUpdate) {
            updateMedication({ ...medicationToUpdate, [field]: value });
        }
    };

    const handleSaveMedDetails = (details) => {
        if (editingMed.id) { // Existing medication
            const medicationToUpdate = medications.find(m => m.id === editingMed.id);
            if (medicationToUpdate) {
                updateMedication({ 
                    ...medicationToUpdate, 
                    intakeSlots: details.slots,
                    intakeDays: details.days,
                    reminders: details.reminders,
                });
            }
        } else { // New medication from queue
            addMedication(editingMed.name, details);
            setMedsToAddQueue(prev => prev.slice(1)); // Dequeue
        }
        setEditingMed(null); // Close modal, allowing useEffect to pick up the next item
    };
    
    const handleDayToggle = (medId, day) => {
        const medicationToUpdate = medications.find(m => m.id === medId);
        if (medicationToUpdate) {
            const newDays = medicationToUpdate.intakeDays.includes(day)
                ? medicationToUpdate.intakeDays.filter(d => d !== day)
                : [...medicationToUpdate.intakeDays, day];
            const dayOrder = ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'];
            newDays.sort((a,b) => dayOrder.indexOf(a) - dayOrder.indexOf(b));

            handleMedUpdate(medId, 'intakeDays', newDays);
        }
    };

    return (
        <div className="view">
            {isMultiSelectModalOpen && (
                <MultiSelectModal
                    pharmacyStock={pharmacyStock}
                    onClose={() => setIsMultiSelectModalOpen(false)}
                    onAdd={(selectedMeds) => {
                        setMedsToAddQueue(selectedMeds);
                        setIsMultiSelectModalOpen(false);
                    }}
                />
            )}
            {editingMed && (
                <ManageTimesModal
                    medName={editingMed.name}
                    initialSlots={editingMed.intakeSlots}
                    initialDays={editingMed.intakeDays}
                    initialReminders={editingMed.reminders}
                    onClose={() => {
                        setEditingMed(null);
                        setMedsToAddQueue([]); // Clear queue on cancel
                    }}
                    onSave={handleSaveMedDetails}
                />
            )}
            
            <div className="add-med-form">
                 <button 
                    className="button button-primary" 
                    style={{width: '100%', flexGrow: 1}}
                    onClick={() => setIsMultiSelectModalOpen(true)}
                >
                    <i className="fa-solid fa-plus" style={{ marginRight: '8px' }}></i>
                    Medikament hinzufügen
                </button>
            </div>

            {medications.length > 0 ? (
                <ul className="med-list">
                    {medications.map(med => {
                        const { name, strength } = parseMedName(med.name);
                        const isBlinking = activeAlarms.some(alarm => alarm.medId === med.id && alarm.isBlinking);
                        return (
                             <li key={med.id} className={`med-item ${isBlinking ? 'blinking' : ''}`}>
                               <div className="med-info">
                                    <div className="med-header">
                                        <h3>
                                            {name}
                                            <span className="med-strength">
                                                {strength}
                                            </span>
                                        </h3>
                                        <label className="switch switch-small" style={{ alignSelf: 'center' }}>
                                            <input
                                                type="checkbox"
                                                checked={med.reminders}
                                                onChange={() => handleMedUpdate(med.id, 'reminders', !med.reminders)}
                                                aria-label={`Erinnerungen für ${med.name} ${med.reminders ? 'deaktivieren' : 'aktivieren'}`}
                                            />
                                            <span className="slider"></span>
                                        </label>
                                    </div>
                                    <div className="intake-times">
                                        <i className="fa-regular fa-clock"></i>
                                        <div className="intake-times-chips">
                                            {med.intakeSlots.map((slot, index) => (
                                                <div key={index} className="intake-slot-group">
                                                    <span className="time-chip">{slot.time}</span>
                                                    <span className="time-chip">{`${slot.dosage} Stk.`}</span>
                                                </div>
                                            ))}
                                        </div>
                                         <button 
                                            className="button-icon-small button-edit"
                                            onClick={() => setEditingMed(med)}
                                            aria-label={`Zeiten für ${name} bearbeiten`}
                                         >
                                            <i className="fa-solid fa-pencil"></i>
                                        </button>
                                    </div>
                                    <WeekDaySelector 
                                        selectedDays={med.intakeDays}
                                        onDayToggle={(day) => handleDayToggle(med.id, day)}
                                    />
                                </div>
                                <div className="med-actions">
                                    <button
                                        className="button-icon"
                                        onClick={() => confirmIntake(med.id)}
                                        aria-label={`Markiere ${med.name} als eingenommen`}
                                    >
                                        <i className="fa-solid fa-check"></i>
                                    </button>
                                    <button
                                        className="button-delete"
                                        onClick={() => deleteMedication(med.id)}
                                        aria-label={`Lösche ${med.name}`}
                                    >
                                        <i className="fa-solid fa-trash"></i>
                                    </button>
                                </div>
                            </li>
                        )
                    })}
                </ul>
            ) : (
                <div className="empty-list">
                    <p>Keine Medikamente hinzugefügt.</p>
                </div>
            )}
        </div>
    );
};

const ProfilAnsicht = ({ profiles, activeProfileId, setActiveProfileId, updateProfile, addProfile, deleteProfile }) => {
    const activeProfile = profiles.find(p => p.id === activeProfileId) || profiles[0];
    
    const [isEditing, setIsEditing] = useState(false);
    const [formData, setFormData] = useState(activeProfile);
    const patientNameInputRef = useRef(null);

    useEffect(() => {
        const currentProfile = profiles.find(p => p.id === activeProfileId);
        if (currentProfile) {
            setFormData(currentProfile);
            if (currentProfile.patientName === '') {
                setIsEditing(true);
            } else {
                setIsEditing(false);
            }
        }
    }, [activeProfileId, profiles]);
    
    useEffect(() => {
        if (isEditing && formData.patientName === '') {
            patientNameInputRef.current?.focus();
        }
    }, [isEditing, formData.patientName]);


    const handleInputChange = (e) => {
        const { name, value } = e.target;
        let formattedValue = value;

        if (name === 'dob') {
            const input = value.replace(/\D/g, '').substring(0, 8);
            const day = input.substring(0, 2);
            const month = input.substring(2, 4);
            const year = input.substring(4, 8);

            if (input.length > 4) {
                formattedValue = `${day}.${month}.${year}`;
            } else if (input.length > 2) {
                formattedValue = `${day}.${month}`;
            } else {
                formattedValue = input;
            }
        }

        if (name === 'doctorPhone') {
            const input = value.replace(/\D/g, '').substring(0, 10);
            if (input.length > 8) {
                formattedValue = `${input.substring(0, 3)} ${input.substring(3, 6)} ${input.substring(6, 8)} ${input.substring(8)}`;
            } else if (input.length > 6) {
                formattedValue = `${input.substring(0, 3)} ${input.substring(3, 6)} ${input.substring(6)}`;
            } else if (input.length > 3) {
                formattedValue = `${input.substring(0, 3)} ${input.substring(3)}`;
            } else {
                formattedValue = input;
            }
        }
        
        setFormData(prev => ({ ...prev, [name]: formattedValue }));
    };

    const handleSave = () => {
        if (!formData.patientName.trim()) {
            alert('Der Patientenname darf nicht leer sein.');
            patientNameInputRef.current?.focus();
            return;
        }
        updateProfile(formData);
        setIsEditing(false);
        alert('Profil gespeichert!');
    };
    
    const handleEdit = () => {
        setIsEditing(true);
    };

    const handleDelete = () => {
        deleteProfile(formData.id);
    };

    return (
        <div className="view">
            <div className="profile-form">
                <div className="form-group profile-switcher">
                    <label htmlFor="profile-select">Aktuelles Profil</label>
                    <div className="profile-controls">
                        <div className="select-container">
                             <select
                                id="profile-select"
                                className="select-style"
                                value={activeProfileId}
                                onChange={(e) => setActiveProfileId(Number(e.target.value))}
                                disabled={isEditing}
                            >
                                {profiles.map(p => (
                                    <option key={p.id} value={p.id}>{p.patientName || 'Neues Profil...'}</option>
                                ))}
                            </select>
                        </div>
                         <button
                            className="button button-small"
                            onClick={addProfile}
                            disabled={isEditing}
                            aria-label="Neues Profil hinzufügen"
                        >
                            <i className="fa-solid fa-plus"></i>
                        </button>
                    </div>
                </div>

                <div className="form-group">
                    <label htmlFor="patientName">Patient</label>
                    <input
                        ref={patientNameInputRef}
                        type="text"
                        id="patientName"
                        name="patientName"
                        className="form-input"
                        placeholder="Max Musterman"
                        value={formData.patientName}
                        onChange={handleInputChange}
                        disabled={!isEditing}
                    />
                </div>
                <div className="form-group">
                    <label htmlFor="dob">Geburtsdatum</label>
                    <input
                        type="text"
                        id="dob"
                        name="dob"
                        className="form-input"
                        value={formData.dob}
                        onChange={handleInputChange}
                        disabled={!isEditing}
                        placeholder="00.00.0000"
                    />
                </div>
                <div className="form-group">
                    <label htmlFor="name">Behandelnder Arzt</label>
                    <div className="prefixed-input">
                         <i className="fa-solid fa-user-doctor input-prefix-icon"></i>
                         <span className="input-prefix-text">Dr.med.</span>
                        <input
                            type="text"
                            id="name"
                            name="name"
                            className="form-input doctor-name-input"
                            value={formData.name}
                            onChange={handleInputChange}
                            disabled={!isEditing}
                            onFocus={e => e.target.setSelectionRange(e.target.value.length, e.target.value.length)}
                        />
                    </div>
                </div>
                <div className="form-group">
                    <label htmlFor="doctorPhone">Telefonnummer des Arztes</label>
                    <div className="prefixed-input">
                         <i className="fa-solid fa-phone input-prefix-icon"></i>
                         <span className="input-prefix-text">Tel.Nr.</span>
                         {isEditing ? (
                            <input
                                type="tel"
                                id="doctorPhone"
                                name="doctorPhone"
                                className="form-input phone-input"
                                value={formData.doctorPhone}
                                onChange={handleInputChange}
                                placeholder="000 000 00 00"
                            />
                        ) : (
                            <a className="form-input phone-input form-input-display" href={`tel:${formData.doctorPhone.replace(/\s/g, '')}`}>
                                {formData.doctorPhone}
                            </a>
                        )}
                    </div>
                </div>
            </div>
            <div className="button-group">
                {!isEditing ? (
                    <>
                        <button className="button button-danger" onClick={handleDelete}>
                            Profil löschen – definitiv
                        </button>
                        <button className="button button-primary" onClick={handleEdit}>
                            Bearbeiten
                        </button>
                    </>
                ) : (
                    <button className="button button-primary" onClick={handleSave}>
                        Speichern
                    </button>
                )}
            </div>
        </div>
    );
};

const ApothekeAnsicht = ({ pharmacyStock, addMedToStock, deleteMedFromStock, medications }) => {
    const [newMedName, setNewMedName] = useState('');
    const [newMedStrength, setNewMedStrength] = useState('');
    const [suggestions, setSuggestions] = useState([]);
    const autocompleteContainerRef = useRef(null);
    const medNameInputRef = useRef(null);

    useEffect(() => {
        const handleClickOutside = (event) => {
            if (autocompleteContainerRef.current && !autocompleteContainerRef.current.contains(event.target)) {
                setSuggestions([]);
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return () => {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, []);

    const handleInputChange = (e) => {
        const value = e.target.value;
        setNewMedName(value);

        if (value.trim().length > 1) {
            const filteredSuggestions = medications
                .filter(med => med.name.toLowerCase().includes(value.toLowerCase()))
                .map(med => med.name);
            setSuggestions(filteredSuggestions);
        } else {
            setSuggestions([]);
        }
    };

    const handleStrengthChange = (e) => {
        const value = e.target.value.replace(/\D/g, '');
        setNewMedStrength(value);
    };

    const handleSuggestionClick = (suggestion) => {
        const { name, strength } = parseMedName(suggestion);
        const strengthValue = strength.replace(/\D/g, '');
        
        setNewMedName(name);
        setNewMedStrength(strengthValue);
        setSuggestions([]);

        const strengthInput = medNameInputRef.current?.closest('.med-input-fields').querySelector('#medStrength');
        if (strengthInput && strengthValue) {
            strengthInput.focus();
        } else {
            medNameInputRef.current?.focus();
        }
    };
    
    const handleAddMed = (e) => {
        e.preventDefault();
        const medName = newMedName.trim();
        if (!medName) {
            alert('Bitte geben Sie einen Medikamentennamen ein.');
            return;
        }

        const fullName = newMedStrength ? `${medName} ${newMedStrength}mg` : medName;

        const isDuplicate = pharmacyStock.some(
            med => med.name.toLowerCase() === fullName.toLowerCase()
        );
        if (isDuplicate) {
            alert('Dieses Medikament ist bereits in Ihrem Vorrat vorhanden.');
            return;
        }

        addMedToStock(fullName);
        setNewMedName('');
        setNewMedStrength('');
        medNameInputRef.current?.focus();
    };

    return (
        <div className="view">
            <form className="add-med-form" onSubmit={handleAddMed}>
                <div className="add-med-controls">
                    <div className="med-input-fields">
                        <div className="autocomplete-container" ref={autocompleteContainerRef}>
                            <input
                                ref={medNameInputRef}
                                id="medName"
                                type="text"
                                className="form-input"
                                placeholder="Medikamentenname"
                                value={newMedName}
                                onChange={handleInputChange}
                                autoComplete="off"
                                required
                            />
                            {suggestions.length > 0 && (
                                <ul className="suggestions-list">
                                    {suggestions.map((s, index) => (
                                        <li key={index} className="suggestion-item" onClick={() => handleSuggestionClick(s)}>
                                            {s}
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>
                        <div className="strength-input-container">
                            <input
                                id="medStrength"
                                type="text"
                                inputMode="numeric"
                                className="form-input"
                                placeholder="Wirkstärke"
                                value={newMedStrength}
                                onChange={handleStrengthChange}
                            />
                            <span>mg</span>
                        </div>
                    </div>
                    <button type="submit" className="button button-small" aria-label="Medikament hinzufügen">
                        <i className="fa-solid fa-plus"></i>
                    </button>
                </div>
            </form>

            <div className="pharmacy-stock">
                <div className="pharmacy-controls">
                    <h2>Ihr Vorrat</h2>
                </div>
                {pharmacyStock.length > 0 ? (
                    <ul className="med-list">
                        {pharmacyStock.map(med => (
                            <li key={med.id} className="med-item pharmacy-item">
                                <span style={{ flexGrow: 1 }}>{med.name}</span>
                                <button className="button-delete" onClick={() => deleteMedFromStock(med.id)} aria-label={`Lösche ${med.name}`}>
                                    <i className="fa-solid fa-trash"></i>
                                </button>
                            </li>
                        ))}
                    </ul>
                ) : (
                    <div className="empty-list">
                        <p>Keine Medikamente im Vorrat.</p>
                    </div>
                )}
            </div>
        </div>
    );
};


const EinstellungenAnsicht = ({ settings, updateSettings }) => {
    
    const handleSoundChange = (event) => {
        const file = event.target.files[0];
        if (file && (file.type === 'audio/mpeg' || file.type === 'audio/wav' || file.type === 'audio/ogg')) {
            const reader = new FileReader();
            // Argument of type 'string | ArrayBuffer' is not assignable to parameter of type 'string'.
            // Added a type guard to ensure e.target.result is a string.
            reader.onload = (e) => {
                if (e.target && typeof e.target.result === 'string') {
                    const base64Sound = e.target.result;
                    updateSettings({
                        ...settings,
                        notificationSound: { name: file.name, data: base64Sound }
                    });
                }
            };
            reader.readAsDataURL(file);
        } else {
            alert('Bitte wählen Sie eine gültige MP3, WAV, oder OGG Datei aus.');
        }
    };

    const handleResetSound = () => {
         updateSettings({
            ...settings,
            notificationSound: { name: 'cock.mp3', data: './cock.mp3' }
        });
    }

    return (
        <div className="view">
            <div className="setting-item">
                <label className="setting-label">Dunkelmodus</label>
                <label className="switch">
                    <input
                        type="checkbox"
                        checked={settings.darkMode}
                        onChange={() => updateSettings({ ...settings, darkMode: !settings.darkMode })}
                    />
                    <span className="slider"></span>
                </label>
            </div>
             <div className="setting-item setting-item-column">
                <label className="setting-label">Alarmton</label>
                <div className="file-upload-container">
                    <div className="file-upload-controls">
                        <div className="sound-info" aria-live="polite">
                            {settings.notificationSound.name ? (
                                <>
                                    <span style={{ textOverflow: 'ellipsis', overflow: 'hidden', whiteSpace: 'nowrap' }}>
                                        {settings.notificationSound.name}
                                    </span>
                                    <button onClick={handleResetSound} className="button-icon-small button-reset" aria-label="Alarmton zurücksetzen">
                                        <i className="fa-solid fa-arrow-rotate-left"></i>
                                    </button>
                                </>
                            ) : (
                                <span className="sound-info-placeholder">Kein Ton ausgewählt</span>
                            )}
                        </div>
                        <label className="button button-primary" style={{ flexGrow: 0, flexBasis: 'auto' }}>
                            <i className="fa-solid fa-upload"></i>
                            <input type="file" accept="audio/mpeg,audio/wav,audio/ogg" onChange={handleSoundChange} style={{ display: 'none' }} />
                        </label>
                    </div>
                    <p className="info-text">MP3, WAV, OGG</p>
                </div>
            </div>
        </div>
    );
};


const App = () => {
    const [profiles, setProfiles] = useState(() => {
        const storedProfiles = getInitialState('profiles', null);

        if (!storedProfiles) {
            return [{ id: 1, patientName: 'Max Musterman', dob: '01.01.1970', name: '', doctorPhone: '', medications: [] }];
        }

        const needsMigration = storedProfiles.length > 0 && !('medications' in storedProfiles[0]);

        if (needsMigration) {
            const migratedProfiles = storedProfiles.map(profile => {
                const oldMedications = getInitialState(`medications_${profile.id}`, []);
                localStorage.removeItem(`medications_${profile.id}`);
                return { ...profile, medications: oldMedications };
            });
            localStorage.setItem('profiles', JSON.stringify(migratedProfiles));
            return migratedProfiles;
        }
        
        return storedProfiles;
    });
    const [activeProfileId, setActiveProfileId] = useState(() => getInitialState('activeProfileId', 1));
    const [pharmacyStock, setPharmacyStock] = useState(() => getInitialState('pharmacyStock', []));
    
    const [settings, setSettings] = useState(() => {
        const defaultSettings = {
            darkMode: false,
            notificationSound: { name: 'cock.mp3', data: './cock.mp3' }
        };
        const storedSettings = getInitialState('settings', defaultSettings);
        // Ensure notificationSound is always an object
        if (!storedSettings.notificationSound || typeof storedSettings.notificationSound !== 'object') {
            storedSettings.notificationSound = defaultSettings.notificationSound;
        }
        return storedSettings;
    });

    const [activeAlarms, setActiveAlarms] = useState([]);
    const [currentTime, setCurrentTime] = useState(new Date());
    const [activeView, setActiveView] = useState('profil');
    const isSoundPlaying = useRef(false);

    // Audio unlock state management
    const [audioUnlocked, setAudioUnlocked] = useState(false);
    const [showUnlockBanner, setShowUnlockBanner] = useState(false);
    
    // Derive medications for the active profile from the main profiles state
    const activeProfile = profiles.find(p => p.id === activeProfileId) || profiles[0] || { medications: [] };
    const medications = activeProfile.medications;

    useEffect(() => {
        // A simple check to see if we can play audio.
        // On many mobile browsers, audio can only be initiated by a user gesture.
        // Fix: Cast window to `any` to allow checking for vendor-prefixed `webkitAudioContext` without TypeScript errors.
        const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
        if (audioContext.state === 'suspended') {
            setShowUnlockBanner(true);
        } else {
            setAudioUnlocked(true);
        }
    }, []);

    const unlockAudio = () => {
        // Fix: Cast window to `any` to allow checking for vendor-prefixed `webkitAudioContext` without TypeScript errors.
        const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                setAudioUnlocked(true);
                setShowUnlockBanner(false);
                // Also play the sound element to unlock it on iOS
                // Fix: Cast the result of getElementById to HTMLAudioElement to access audio-specific methods.
                const sound = document.getElementById('notification-sound') as HTMLAudioElement;
                if (sound) {
                    sound.play().then(() => sound.pause()).catch(() => {});
                }
            });
        } else {
            setAudioUnlocked(true);
            setShowUnlockBanner(false);
        }
    };
    

    // Save to localStorage whenever a state changes
    useEffect(() => localStorage.setItem('profiles', JSON.stringify(profiles)), [profiles]);
    useEffect(() => localStorage.setItem('activeProfileId', JSON.stringify(activeProfileId)), [activeProfileId]);
    useEffect(() => localStorage.setItem('pharmacyStock', JSON.stringify(pharmacyStock)), [pharmacyStock]);
    useEffect(() => localStorage.setItem('settings', JSON.stringify(settings)), [settings]);

    // Dark mode handler
    useEffect(() => {
        const root = document.documentElement;
        const metaThemeColor = document.querySelector('meta[name="theme-color"]');
        if (settings.darkMode) {
            root.style.setProperty('--base-bg-color', '#2a2f3a');
            root.style.setProperty('--text-color', '#e0e5ec');
            root.style.setProperty('--text-color-light', '#a3b1c6');
            root.style.setProperty('--shadow-light', '#343a45');
            root.style.setProperty('--shadow-dark', '#202530');
            root.style.setProperty('--border-color', '#343a45');
            root.style.setProperty('--disabled-bg-color', '#343a45');
            root.style.setProperty('--switch-thumb-bg', '#e0e5ec');
             root.style.setProperty('--blinking-bg-color', 'hsl(223, 17%, 25%)');
            root.style.setProperty('--blinking-shadow-color', 'hsla(235, 85%, 70%, 1)');
            root.style.setProperty('--small-switch-thumb-bg', 'linear-gradient(145deg, #2d323e, #262a34)');
             root.style.setProperty('--nav-bar-shadow', '0 -4px 12px rgba(0, 0, 0, 0.3)');
            if (metaThemeColor) metaThemeColor.setAttribute('content', '#2a2f3a');
        } else {
            root.style.setProperty('--base-bg-color', '#e0e5ec');
            root.style.setProperty('--text-color', '#5a6473');
            root.style.setProperty('--text-color-light', '#606e85');
            root.style.setProperty('--shadow-light', '#ffffff');
            root.style.setProperty('--shadow-dark', '#a3b1c6');
            root.style.setProperty('--border-color', '#d1d9e6');
            root.style.setProperty('--disabled-bg-color', '#d1d9e6');
            root.style.setProperty('--switch-thumb-bg', 'white');
            root.style.setProperty('--blinking-bg-color', 'hsl(235, 85%, 94%)');
            root.style.setProperty('--blinking-shadow-color', 'hsla(235, 85%, 70%, 1)');
            root.style.setProperty('--small-switch-thumb-bg', 'linear-gradient(145deg, #f0f2f5, #c8d0e7)');
            root.style.setProperty('--nav-bar-shadow', '0 -4px 12px rgba(0, 0, 0, 0.1)');
            if (metaThemeColor) metaThemeColor.setAttribute('content', '#e0e5ec');
        }
    }, [settings.darkMode]);

    // Update audio source
    useEffect(() => {
        // Fix: Cast the result of getElementById to HTMLAudioElement to access the 'src' property.
        const audio = document.getElementById('notification-sound') as HTMLAudioElement;
        if (audio) {
            audio.src = settings.notificationSound.data;
        }
    }, [settings.notificationSound]);
    
    // Timer and alarm logic
    useEffect(() => {
        const timer = setInterval(() => {
            setCurrentTime(new Date());
        }, 1000); // Update time every second
        return () => clearInterval(timer);
    }, []);

    useEffect(() => {
        const dayOfWeek = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'][currentTime.getDay()];
        const currentTimeStr = currentTime.toTimeString().slice(0, 5);

        const newAlarms = [];
        medications.forEach(med => {
            if (med.reminders && med.intakeDays.includes(dayOfWeek)) {
                med.intakeSlots.forEach(slot => {
                    if (slot.time === currentTimeStr) {
                        const isAlreadyActive = activeAlarms.some(a => a.medId === med.id && a.time === slot.time);
                        if (!isAlreadyActive) {
                            newAlarms.push({ medId: med.id, time: slot.time, isBlinking: true });
                        }
                    }
                });
            }
        });

        if (newAlarms.length > 0) {
            setActiveAlarms(prev => {
                const updatedAlarms = [...prev];
                newAlarms.forEach(newAlarm => {
                    if (!updatedAlarms.some(existing => existing.medId === newAlarm.medId && existing.time === newAlarm.time)) {
                       updatedAlarms.push(newAlarm);
                    }
                });
                return updatedAlarms;
            });
        }
    }, [currentTime, medications]);
    
    // Sound playback logic
    useEffect(() => {
        const alarmToPlay = activeAlarms[0];

        // Nur fortfahren, wenn ein Alarm vorhanden ist, wir nicht bereits einen Ton abspielen und der Ton freigeschaltet ist
        if (alarmToPlay && !isSoundPlaying.current && audioUnlocked) {
            // Fix: Cast the result of getElementById to HTMLAudioElement to access audio-specific properties.
            const sound = document.getElementById('notification-sound') as HTMLAudioElement;
            
            if (sound && sound.src) {
                isSoundPlaying.current = true;
                sound.play()
                    .then(() => {
                        // Ton beendet, diesen Alarm aus der Warteschlange entfernen.
                        setActiveAlarms(prev => prev.slice(1));
                    })
                    .catch(error => {
                        console.error('Audio-Wiedergabe fehlgeschlagen:', error);
                        // Alarm auch bei Fehler entfernen, um ein Hängenbleiben zu verhindern.
                        setActiveAlarms(prev => prev.slice(1));
                    })
                    .finally(() => {
                        // Sicherstellen, dass der nächste Ton abgespielt werden kann.
                        isSoundPlaying.current = false;
                    });
            } else {
                // Wenn keine Tondatei vorhanden ist, "bestätigen" wir den Alarm automatisch
                // nach einer kurzen Verzögerung, damit der Benutzer das visuelle Feedback sehen kann.
                setTimeout(() => {
                    setActiveAlarms(prev => prev.slice(1));
                }, 1000);
            }
        } else if (activeAlarms.length === 0) {
            // Fix: Cast the result of getElementById to HTMLAudioElement to access audio-specific properties.
            const sound = document.getElementById('notification-sound') as HTMLAudioElement;
            if(sound && !sound.paused) {
                sound.pause();
                sound.currentTime = 0;
                isSoundPlaying.current = false;
            }
        }
    }, [activeAlarms, audioUnlocked]);

    const updateActiveProfileMedications = (newMedications) => {
        setProfiles(currentProfiles =>
            currentProfiles.map(p =>
                p.id === activeProfileId ? { ...p, medications: newMedications } : p
            )
        );
    };

    // --- Medication Management ---
    const addMedication = (medName, details) => {
        const newMed = {
            id: Date.now(),
            name: medName,
            reminders: details.reminders,
            intakeSlots: details.slots,
            intakeDays: details.days,
        };
        const currentMedications = (profiles.find(p => p.id === activeProfileId) || { medications: [] }).medications;
        updateActiveProfileMedications([...currentMedications, newMed]);
    };

    const deleteMedication = (id) => {
        const currentMedications = (profiles.find(p => p.id === activeProfileId) || { medications: [] }).medications;
        updateActiveProfileMedications(currentMedications.filter(m => m.id !== id));
    };

    const updateMedication = (updatedMed) => {
         const currentMedications = (profiles.find(p => p.id === activeProfileId) || { medications: [] }).medications;
        updateActiveProfileMedications(currentMedications.map(m => (m.id === updatedMed.id ? updatedMed : m)));
    };

    const confirmIntake = (medId, specificTime = null) => {
        setActiveAlarms(prev => {
            if (specificTime) {
                return prev.filter(a => !(a.medId === medId && a.time === specificTime));
            }
            // Fallback for the checkmark button if no specific time is known
            const alarmsForMed = prev.filter(a => a.medId === medId);
            if (alarmsForMed.length > 0) {
                // Remove the earliest alarm for this med
                const earliestTime = alarmsForMed.sort((a,b) => a.time.localeCompare(b.time))[0].time;
                return prev.filter(a => !(a.medId === medId && a.time === earliestTime));
            }
            return prev;
        });
        // Potentially add logic here for history/logging
    };
    
    // --- Pharmacy Stock Management ---
    const addMedToStock = (medName) => {
        const newMed = { id: Date.now(), name: medName };
        setPharmacyStock(prev => [...prev, newMed].sort((a, b) => a.name.localeCompare(b.name)));
    };

    const deleteMedFromStock = (id) => {
        setPharmacyStock(pharmacyStock.filter(m => m.id !== id));
    };

    // --- Profile Management ---
    const addProfile = () => {
        const newProfileId = Date.now();
        const newProfile = { id: newProfileId, patientName: '', dob: '', name: '', doctorPhone: '', medications: [] };
        setProfiles(prev => [...prev, newProfile]);
        setActiveProfileId(newProfileId);
    };

    const updateProfile = (updatedProfile) => {
        setProfiles(profiles.map(p => p.id === updatedProfile.id ? updatedProfile : p));
    };
    
    const deleteProfile = (id) => {
        if (profiles.length <= 1) {
            alert("Das letzte Profil kann nicht gelöscht werden.");
            return;
        }
        if (confirm("Sind Sie sicher, dass Sie dieses Profil und alle zugehörigen Medikamentenpläne löschen möchten?")) {
            const remainingProfiles = profiles.filter(p => p.id !== id);
            setProfiles(remainingProfiles);
            // Switch to the first available profile
            setActiveProfileId(remainingProfiles[0].id);
        }
    };
    
    const renderView = () => {
        switch (activeView) {
            case 'plan':
                return <EinnahmeplanAnsicht
                            medications={medications}
                            pharmacyStock={pharmacyStock.filter(stockMed => !medications.some(planMed => planMed.name === stockMed.name))}
                            addMedication={addMedication}
                            deleteMedication={deleteMedication}
                            updateMedication={updateMedication}
                            activeAlarms={activeAlarms}
                            confirmIntake={confirmIntake}
                        />;
            case 'apotheke':
                return <ApothekeAnsicht 
                            pharmacyStock={pharmacyStock}
                            addMedToStock={addMedToStock}
                            deleteMedFromStock={deleteMedFromStock}
                            medications={[...medications, ...pharmacyStock]}
                        />;
            case 'profil':
                return <ProfilAnsicht 
                            profiles={profiles}
                            activeProfileId={activeProfileId}
                            setActiveProfileId={setActiveProfileId}
                            updateProfile={updateProfile}
                            addProfile={addProfile}
                            deleteProfile={deleteProfile}
                        />;
            case 'einstellungen':
                return <EinstellungenAnsicht 
                            settings={settings}
                            updateSettings={setSettings}
                       />;
            default:
                return null;
        }
    };
    
    const getHeaderInfo = () => {
        switch(activeView) {
            case 'plan': return { icon: 'fa-solid fa-pills', title: 'Einnahmeplan' };
            case 'apotheke': return { icon: 'fa-solid fa-mortar-pestle', title: 'Apotheke' };
            case 'profil': return { icon: 'fa-solid fa-user', title: 'Patientenprofil' };
            case 'einstellungen': return { icon: 'fa-solid fa-gear', title: 'Einstellungen' };
            default: return { icon: '', title: '' };
        }
    };
    
    const { icon, title } = getHeaderInfo();

    return (
        <div className="app-container">
            {activeView === 'profil' && <h2 className="main-app-title">Medi-Manager</h2>}
            {showUnlockBanner && (
                <div className="audio-unlock-banner" onClick={unlockAudio}>
                    <i className="fa-solid fa-volume-up"></i>
                    Tippen, um Ton zu aktivieren
                </div>
            )}
            <div className="app-header">
                <div className={`header-icon ${icon}`}></div>
                <h1>{title}</h1>
            </div>

            {renderView()}

            <nav className="nav-bar">
                <button className={`nav-item ${activeView === 'profil' ? 'active' : ''}`} onClick={() => setActiveView('profil')} aria-label="Profil"><i className="fa-solid fa-user"></i></button>
                <button className={`nav-item ${activeView === 'plan' ? 'active' : ''}`} onClick={() => setActiveView('plan')} aria-label="Einnahmeplan"><i className="fa-solid fa-pills"></i></button>
                <button className={`nav-item ${activeView === 'apotheke' ? 'active' : ''}`} onClick={() => setActiveView('apotheke')} aria-label="Apotheke"><i className="fa-solid fa-mortar-pestle"></i></button>
                <button className={`nav-item ${activeView === 'einstellungen' ? 'active' : ''}`} onClick={() => setActiveView('einstellungen')} aria-label="Einstellungen"><i className="fa-solid fa-gear"></i></button>
            </nav>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
